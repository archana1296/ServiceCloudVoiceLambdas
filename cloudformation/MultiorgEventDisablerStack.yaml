AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template for multiorg event disabler - inline Lambda function disables conflicting single-org event sources during multiorg migration.

Parameters:
  ExistingCallCenterApiName:
    Type: String
    Default: ""
    Description: Salesforce Existing CallCenter API name

  lambdaPrefix:
    Type: String
    Default: scvMultiorg
    Description: Prefix for Lambda function names

  ConnectInstanceId:
    Type: String
    Description: Amazon Connect Instance ID

  PermissionBoundaryARN:
    Type: String
    Description: Permission boundary ARN for IAM roles
    Default: ""

Conditions:
  PermissionBoundaryIsNull: !Equals [!Ref PermissionBoundaryARN, ""]

Resources:

  MultiorgMigrationRole:
    Type: AWS::IAM::Role
    Properties:
      PermissionsBoundary:
        !If [PermissionBoundaryIsNull, !Ref "AWS::NoValue", !Ref PermissionBoundaryARN]
      RoleName: !Sub "${lambdaPrefix}-MultiorgMigrationRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: MultiorgMigrationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - connect:ListInstanceStorageConfigs
                Resource: !Sub "arn:${AWS::Partition}:connect:${AWS::Region}:${AWS::AccountId}:instance/*"

              - Effect: Allow
                Action:
                  - lambda:ListEventSourceMappings
                Resource: "*"

              - Effect: Allow
                Action:
                  - lambda:UpdateEventSourceMapping
                  - lambda:GetEventSourceMapping
                Resource: !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:event-source-mapping:*"

              - Effect: Allow
                Action:
                  - events:ListRules
                Resource: "*"

              - Effect: Allow
                Action:
                  - events:DisableRule
                  - events:ListTargetsByRule
                  - events:DescribeRule
                Resource:
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*ContactEventsRule"
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*ScheduledRule"
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*VoiceMailAudioProcessingFunction*"
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*VoiceMailTranscribeFunction*"
                  - !Sub "arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/*VoiceMailPackagingFunction*"

              - Effect: Allow
                Action:
                  - lambda:GetFunction
                Resource:
                  - !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*"

  MultiorgMigrationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${lambdaPrefix}-EnterpriseEventManagement"
      Description: "Disables conflicting single-org event sources during multiorg migration"
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt MultiorgMigrationRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import os
          import re
          from typing import Dict, List, Any

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # AWS clients
          lambda_client = boto3.client('lambda')
          events_client = boto3.client('events')
          connect_client = boto3.client('connect')

          def handler(event, context):
              """
              Multiorg Event Source Mapping Migration Function
              Disables conflicting single-org event sources without creating new ones
              """
              error_log = []
          
              try:
                  request_param = event['ResourceProperties']

                  existing_call_center_api_name = request_param['existing_call_center_api_name']
                  connect_instance_id = request_param['connect_instance_id']
                  lambda_prefix = request_param['lambda_prefix']

                  # Discover streams from Connect instance
                  discovered_streams = discover_connect_associtated_resources(connect_instance_id)
                  ctr_stream_arn = discovered_streams.get('ctr_stream_arn')
                  contact_lens_stream_arn = discovered_streams.get('contact_lens_stream_arn')

                  logger.info(f"Discovered CTR Stream ARN: {ctr_stream_arn}")
                  logger.info(f"Discovered Contact Lens Stream ARN: {contact_lens_stream_arn}")

                  result = {
                      'status': 'success',
                      'ctr_migration': None,
                      'contact_lens_migration': None,
                      'eventbridge_migration': None,
                      's3_eventbridge_migration': None,
                      'errors': [],
                      'streams_discovered': {
                          'ctr_stream_arn': ctr_stream_arn,
                          'contact_lens_stream_arn': contact_lens_stream_arn
                      },
                      'stream_discovery': discovered_streams
                  }

                  try:
                      if ctr_stream_arn:
                          result['ctr_migration'] = disable_event_source_mappings(
                              ctr_stream_arn, 
                              'CTR',
                              lambda_prefix,
                              error_log
                          )
                      else:
                          result['ctr_migration'] = {
                              'skipped': 'No CTR stream found in Connect instance'
                          }
                  except Exception as e:
                      error_msg = f"CTR migration failed: {str(e)}"
                      logger.warning(error_msg)
                      error_log.append({
                          'component': 'CTR Migration',
                          'error': error_msg,
                          'manual_action': 'Check CTR stream event source mappings in Lambda console'
                      })
                      result['ctr_migration'] = {'error': error_msg}

                  try:
                      if contact_lens_stream_arn:
                          result['contact_lens_migration'] = disable_event_source_mappings(
                              contact_lens_stream_arn,
                              'ContactLens',
                              lambda_prefix,
                              error_log
                          )
                      else:
                          result['contact_lens_migration'] = {
                              'skipped': 'No Contact Lens stream found in Connect instance'
                          }
                  except Exception as e:
                      error_msg = f"Contact Lens migration failed: {str(e)}"
                      logger.warning(error_msg)
                      error_log.append({
                          'component': 'Contact Lens Migration',
                          'error': error_msg,
                          'manual_action': 'Check Contact Lens stream event source mappings in Lambda console'
                      })
                      result['contact_lens_migration'] = {'error': error_msg}

                  try:
                      result['eventbridge_migration'] = disable_conflicting_eventbridge_rules(
                          existing_call_center_api_name,
                          lambda_prefix,
                          error_log
                      )
                  except Exception as e:
                      error_msg = f"EventBridge migration failed: {str(e)}"
                      logger.warning(error_msg)
                      error_log.append({
                          'component': 'EventBridge Migration',
                          'error': error_msg,
                          'manual_action': 'Check EventBridge rules in AWS Console'
                      })
                      result['eventbridge_migration'] = {'error': error_msg}

                  try:
                      result['s3_eventbridge_migration'] = disable_s3_eventbridge_rules(
                          lambda_prefix,
                          discovered_streams.get('s3_bucket_name'),
                          error_log
                      )
                  except Exception as e:
                      error_msg = f"S3 EventBridge migration failed: {str(e)}"
                      logger.warning(error_msg)
                      error_log.append({
                          'component': 'S3 EventBridge Migration',
                          'error': error_msg,
                          'manual_action': 'Check S3-related EventBridge rules in AWS Console'
                      })
                      result['s3_eventbridge_migration'] = {'error': error_msg}

                  # Set final status
                  if error_log:
                      result['errors'] = error_log
                      logger.warning(f"Migration completed with {len(error_log)} warnings/errors")
                  else:
                      logger.info("Migration completed successfully")

                  # Send CloudFormation response
                  if 'ResourceProperties' in event:
                      send_cfn_response(event, context, 'SUCCESS', result)
          
                  return result

              except Exception as e:
                  error_msg = f"Critical migration failure: {str(e)}"
                  logger.error(error_msg, exc_info=True)
          
                  # Even for critical failures, return SUCCESS to prevent stack failure
                  logger.error("=== CRITICAL ERROR - MANUAL INTERVENTION REQUIRED ===")
                  logger.error("MANUAL ACTION: Check CloudWatch logs for detailed error information")
                  logger.error("MANUAL ACTION: Verify Lambda function permissions and configurations")
                  logger.error("MANUAL ACTION: Check EventBridge rules and event source mappings manually")
                  logger.error("=== END CRITICAL ERROR ===")

                  # Always return SUCCESS to CloudFormation to prevent stack failures
                  if 'ResourceProperties' in event:
                      send_cfn_response(event, context, 'SUCCESS', {
                          'status': 'critical_error_manual_intervention_required',
                          'error': error_msg,
                          'manual_actions': [
                              'Check CloudWatch logs for detailed error information',
                              'Verify Lambda function permissions and configurations', 
                              'Check EventBridge rules and event source mappings manually'
                          ]
                      })
          
                  logger.info("=== MIGRATION FUNCTION COMPLETED (WITH CRITICAL ERROR) ===")
                  return {'status': 'critical_error', 'message': error_msg, 'requires_manual_intervention': True}

          def discover_connect_associtated_resources(connect_instance_id: str) -> Dict[str, Any]:
              """Discover stream ARNs and S3 bucket from Connect instance configuration"""
              try:
                  result = {
                      'connect_instance_id': connect_instance_id,
                      'ctr_stream_arn': None,
                      'contact_lens_stream_arn': None,
                      's3_bucket_name': None,
                      'status': 'success',
                      'warnings': []
                  }
          
                  # Discover CTR stream
                  try:
                      ctr_paginator = connect_client.get_paginator('list_instance_storage_configs')
                      for ctr_page in ctr_paginator.paginate(
                          InstanceId=connect_instance_id,
                          ResourceType='CONTACT_TRACE_RECORDS'
                      ):
                          for config in ctr_page.get('StorageConfigs', []):
                              storage_type = config.get('StorageType', '')
                              if storage_type in ['KINESIS_DATA_STREAM', 'KINESIS_STREAM']:
                                  stream_arn = config.get('KinesisStreamConfig', {}).get('StreamArn', '')
                                  if stream_arn:
                                      result['ctr_stream_arn'] = stream_arn
                                      logger.info(f"Discovered CTR stream: {stream_arn}")
                                      break
          
                      if not result['ctr_stream_arn']:
                          result['warnings'].append("No CTR stream found in Connect instance")
                          logger.warning("No CTR stream found in Connect instance")
          
                  except Exception as e:
                      error_msg = f"Error discovering CTR stream: {str(e)}"
                      result['warnings'].append(error_msg)
                      logger.warning(error_msg)
          
                  # Discover Contact Lens stream
                  try:
                      cl_paginator = connect_client.get_paginator('list_instance_storage_configs')
                      for cl_page in cl_paginator.paginate(
                          InstanceId=connect_instance_id,
                          ResourceType='REAL_TIME_CONTACT_ANALYSIS_SEGMENTS'
                      ):
                          for config in cl_page.get('StorageConfigs', []):
                              storage_type = config.get('StorageType', '')
                              if storage_type in ['KINESIS_DATA_STREAM', 'KINESIS_STREAM']:
                                  stream_arn = config.get('KinesisStreamConfig', {}).get('StreamArn', '')
                                  if stream_arn:
                                      result['contact_lens_stream_arn'] = stream_arn
                                      break
          
                      if not result['contact_lens_stream_arn']:
                          result['warnings'].append("No Contact Lens stream found in Connect instance")
                          logger.warning("No Contact Lens stream found in Connect instance")
          
                  except Exception as e:
                      error_msg = f"Error discovering Contact Lens stream: {str(e)}"
                      result['warnings'].append(error_msg)
                      logger.warning(error_msg)
          
                  # Discover S3 bucket for call recordings
                  try:
                      s3_paginator = connect_client.get_paginator('list_instance_storage_configs')
                      for s3_page in s3_paginator.paginate(
                          InstanceId=connect_instance_id,
                          ResourceType='CALL_RECORDINGS'
                      ):
                          for config in s3_page.get('StorageConfigs', []):
                              storage_type = config.get('StorageType', '')
                              if storage_type == 'S3':
                                  bucket_name = config.get('S3Config', {}).get('BucketName', '')
                                  if bucket_name:
                                      result['s3_bucket_name'] = bucket_name
                                      logger.info(f"Discovered S3 bucket: {bucket_name}")
                                      break
          
                      if not result['s3_bucket_name']:
                          result['warnings'].append("No S3 bucket found for call recordings in Connect instance")
                          logger.warning("No S3 bucket found for call recordings in Connect instance")
          
                  except Exception as e:
                      error_msg = f"Error discovering S3 bucket: {str(e)}"
                      result['warnings'].append(error_msg)
                      logger.warning(error_msg)
          
                  return result
          
              except Exception as e:
                  error_msg = f"Error discovering Connect streams: {str(e)}"
                  logger.warning(error_msg)
                  return {
                      'connect_instance_id': connect_instance_id,
                      'ctr_stream_arn': None,
                      'contact_lens_stream_arn': None,
                      's3_bucket_name': None,
                      'status': 'error',
                      'error': error_msg,
                      'warnings': [error_msg]
                  }

          def disable_event_source_mappings(stream_arn: str, stream_type: str, lambda_prefix: str, error_log: List[Dict[str, str]]) -> Dict[str, Any]:
              """Disable event source mappings for a specific stream"""
              try:
                  if not stream_arn:
                      return {'skipped': f'No {stream_type} stream ARN found'}
          
                  result = {
                      'disabled_mappings': [],
                      'kept_mappings': []
                  }
          
                  logger.debug(f"Getting event source mappings for {stream_type} stream: {stream_arn}")
                  paginator = lambda_client.get_paginator('list_event_source_mappings')
                  existing_mappings = []
          
                  for page in paginator.paginate(EventSourceArn=stream_arn):
                      existing_mappings.extend(page.get('EventSourceMappings', []))
          
                  logger.info(f"Found {len(existing_mappings)} event source mappings for {stream_type} stream")
          
                  for mapping in existing_mappings:
                      function_arn = mapping.get('FunctionArn', '')
                      uuid = mapping.get('UUID', '')
                      state = mapping.get('State', '')
          
                      # Check if this is the current/correct multiorg function that should be kept
                      if is_current_multiorg_function(function_arn, lambda_prefix):
                          logger.debug(f"Keeping current multiorg function: {function_arn}")
                          result['kept_mappings'].append({
                              'uuid': uuid,
                              'function_arn': function_arn,
                              'action': 'kept_current_multiorg',
                              'reason': 'current_multiorg_function'
                          })
                          continue
          
                      # Check if it's any SCV-related function (single-org OR old multiorg) that should be disabled
                      if is_scv_function(function_arn):
                          if state == 'Enabled':
                              logger.info(f"Disabling event source mapping for SCV function: {function_arn}")
                              try:
                                  lambda_client.update_event_source_mapping(
                                      UUID=uuid,
                                      Enabled=False
                                  )
                                  result['disabled_mappings'].append({
                                      'uuid': uuid,
                                      'function_arn': function_arn,
                                      'action': 'disabled',
                                      'reason': 'Disabling old eventSource Mapping'
                                  })
                              except Exception as e:
                                  logger.warning(f"Failed to disable mapping {uuid}: {str(e)}")
                          else:
                              logger.debug(f"Event source mapping already disabled: {function_arn}")
                              result['disabled_mappings'].append({
                                  'uuid': uuid,
                                  'function_arn': function_arn,
                                  'action': 'already_disabled',
                                  'reason': 'already_disabled_event_source_mapping'
                          })
                      else:
                          # Not an SCV function - keep it
                          logger.debug(f"Keeping customer function: {function_arn}")
                          result['kept_mappings'].append({
                              'uuid': uuid,
                              'function_arn': function_arn,
                              'action': 'kept_customer_function',
                              'reason': 'customer_function'
                          })
          
                  # Summary
                  disabled_count = len([m for m in result['disabled_mappings'] if m['action'] == 'disabled'])
                  kept_customer_count = len([m for m in result['kept_mappings'] if 'customer_function' in m.get('reason', '')])
          
                  logger.info(f"{stream_type} migration summary:")
                  logger.info(f"  - Disabled old SCV mappings: {disabled_count}")
                  logger.info(f"  - Kept customer mappings: {kept_customer_count}")
                  logger.info(f"  - Kept current multiorg mappings: {len([m for m in result['kept_mappings'] if 'multiorg' in m.get('reason', '')])}")
          
                  return result
          
              except Exception as e:
                  error_msg = f"Error processing {stream_type} stream event source mappings: {str(e)}"
                  logger.warning(error_msg)
                  error_log.append({
                      'component': f'{stream_type} Stream Migration',
                      'error': error_msg,
                      'manual_action': f'Manually check {stream_type} stream event source mappings in Lambda console'
                  })
                  return {'error': error_msg}

          def disable_conflicting_eventbridge_rules(existing_call_center_api_name: str, lambda_prefix: str, error_log: List[Dict[str, str]]) -> Dict[str, Any]:
              """Disable conflicting EventBridge rules - only disables, never creates"""
              try:
                  result = {
                      'disabled_rules': [],
                      'kept_rules': []
                  }
          
                  # Check common rule patterns and disable if conflicting
                  rule_patterns_to_check = [
                      f"{existing_call_center_api_name}-ContactEventsRule",
                      f"{existing_call_center_api_name}-ScheduledRule"
                  ]
          
                  # Check specific rule patterns first
                  for rule_name in rule_patterns_to_check:
                      disable_result = disable_rule_if_conflicting(rule_name, lambda_prefix)
                      if disable_result:
                          result['disabled_rules'].append(disable_result)
          
                  # Check for SCV rules
                  paginator = events_client.get_paginator('list_rules')
                  for page in paginator.paginate():
                      for rule in page.get('Rules', []):
                          rule_name = rule.get('Name', '')
                          if is_scv_rule(rule_name):
                              disable_result = disable_rule_if_conflicting(rule_name, lambda_prefix)
                              if disable_result:
                                  result['disabled_rules'].append(disable_result)
          
                  return result
          
              except Exception as e:
                  error_msg = f"Error disabling EventBridge rules: {str(e)}"
                  logger.warning(error_msg)
                  error_log.append({
                      'component': 'EventBridge Rules Migration',
                      'error': error_msg,
                      'manual_action': 'Manually check EventBridge rules in AWS Console'
                  })
                  return {'error': error_msg}

          def disable_s3_eventbridge_rules(lambda_prefix: str, s3_bucket_name: str, error_log: List[Dict[str, str]]) -> Dict[str, Any]:
              """Disable conflicting S3 EventBridge rules for voicemail processing"""
              try:
                  result = {
                      'disabled_rules': [],
                      'kept_rules': []
                  }
          
                  # Get all EventBridge rules
                  paginator = events_client.get_paginator('list_rules')
                  for page in paginator.paginate():
                      for rule in page.get('Rules', []):
                          rule_name = rule.get('Name', '')
          
                          try:
                              # Get rule details to check EventPattern
                              rule_details = events_client.describe_rule(Name=rule_name)
                              event_pattern = rule_details.get('EventPattern')
          
                              if not event_pattern:
                                  continue
          
                              # Parse EventPattern (could be string or dict)
                              if isinstance(event_pattern, str):
                                  try:
                                      pattern_obj = json.loads(event_pattern)
                                  except json.JSONDecodeError:
                                      continue
                              else:
                                  pattern_obj = event_pattern
          
                              # Check for S3 voicemail rules
                              if is_s3_voicemail_rule(pattern_obj, s3_bucket_name):
                                  logger.debug(f"Found S3 voicemail rule: {rule_name}")
          
                                  # Check if this rule should be kept (matches current lambda prefix)
                                  if should_keep_s3_rule(rule_name, lambda_prefix):
                                      logger.debug(f"Keeping current multiorg S3 rule: {rule_name}")
                                      result['kept_rules'].append({
                                          'rule_name': rule_name,
                                          'action': 'kept_current_multiorg',
                                          'reason': 'current_multiorg_s3_rule'
                                      })
                                  else:
                                      # Disable the rule
                                      disable_result = disable_rule_if_conflicting(rule_name, lambda_prefix)
                                      if disable_result:
                                          result['disabled_rules'].append(disable_result)
                                          logger.info(f"Disabled old S3 voicemail rule: {rule_name}")
          
                          except Exception as e:
                              logger.debug(f"Error checking rule {rule_name}: {str(e)}")
                              continue
          
                  disabled_count = len(result['disabled_rules'])
                  kept_count = len(result['kept_rules'])
                  logger.info(f"S3 EventBridge migration summary: disabled {disabled_count}, kept {kept_count} rules")
          
                  return result
          
              except Exception as e:
                  error_msg = f"Error disabling S3 EventBridge rules: {str(e)}"
                  logger.warning(error_msg)
                  error_log.append({
                      'component': 'S3 EventBridge Rules Migration',
                      'error': error_msg,
                      'manual_action': 'Manually check S3-related EventBridge rules in AWS Console'
                  })
                  return {'error': error_msg}

          def is_s3_voicemail_rule(pattern_obj: Dict, s3_bucket_name: str = None) -> bool:
              """Check if EventPattern is for S3 voicemail events"""
              try:
                  # Check for S3 source
                  if 'aws.s3' not in pattern_obj.get('source', []):
                      return False
          
                  # Check for Object Created detail-type
                  detail_types = pattern_obj.get('detail-type', [])
                  if 'Object Created' not in detail_types:
                      return False
          
                  # Check for voicemail paths in object key prefixes
                  detail = pattern_obj.get('detail', {})
                  object_config = detail.get('object', {})
                  key_filters = object_config.get('key', [])
          
                  voicemail_indicators = [
                      'voicemail_transcripts/',
                      'voicemail_recordings/'
                  ]
          
                  # Check if any key filter contains voicemail indicators
                  pattern_str = json.dumps(pattern_obj).lower()
                  has_voicemail_pattern = any(indicator in pattern_str for indicator in voicemail_indicators)
          
                  if has_voicemail_pattern:
                      logger.debug(f"Found S3 voicemail rule pattern")
                      return True
          
                  return False
          
              except Exception as e:
                  logger.debug(f"Error checking S3 voicemail pattern: {str(e)}")
                  return False

          def should_keep_s3_rule(rule_name: str, lambda_prefix: str) -> bool:
              """Check if S3 rule should be kept (belongs to current multiorg setup)"""
              if not rule_name or not lambda_prefix:
                  return False
          
              # Check if rule name contains current lambda prefix
              # Current multiorg rules should have the lambda prefix in the name
              return lambda_prefix in rule_name

          def disable_rule_if_conflicting(rule_name: str, lambda_prefix: str) -> Dict[str, Any]:
              """Check if rule is conflicting and disable it"""
              try:
                  rule = events_client.describe_rule(Name=rule_name)
                  if rule.get('State') != 'ENABLED':
                      return None
          
                  # Check if rule targets any current multiorg functions
                  targets_response = events_client.list_targets_by_rule(Rule=rule_name)
                  for target in targets_response.get('Targets', []):
                      target_arn = target.get('Arn', '')
                      if is_current_multiorg_function(target_arn, lambda_prefix):
                          logger.info(f"Keeping rule '{rule_name}' as it targets current multiorg function: {target_arn}")
                          return None
          
                  logger.info(f"Disabling conflicting rule: {rule_name}")
                  events_client.disable_rule(Name=rule_name)
                  return {
                      'rule_name': rule_name,
                      'action': 'disabled',
                      'reason': 'conflicting_scv_rule'
                  }
          
              except events_client.exceptions.ResourceNotFoundException:
                  logger.info(f"Rule '{rule_name}' not found, skipping")
                  return None
              except Exception as e:
                  logger.error(f"Error processing rule '{rule_name}': {str(e)}")
                  return None

          def is_current_multiorg_function(function_arn: str, lambda_prefix: str) -> bool:
              """Check if function is the current/correct multiorg function that should be kept"""
              if not function_arn or not lambda_prefix:
                  return False
          
              function_name = function_arn.split(':')[-1]
          
              if is_scv_function(function_arn):
                  return function_name.startswith(lambda_prefix)
          
              return False

          def is_scv_function(function_arn: str) -> bool:
              """Check if function is a consumer function that needs to be disabled"""
              if not function_arn:
                  return False
          
              function_name = function_arn.split(':')[-1]
          
              # Only consumer functions that we need to disable during migration
              consumer_patterns = [
                  # CTR Data Sync consumers
                  r'^[a-zA-Z0-9_-]+-CTRDataSyncFunction$',
          
                  # Contact Lens consumers  
                  r'^[a-zA-Z0-9_-]+-ContactLensConsumerFunction$',
                  r'^[a-zA-Z0-9_-]+-ContactLensConsumer$',
          
                  # Handle Contact Events (EventBridge aws.connect consumer)
                  r'^[a-zA-Z0-9_-]+-HandleContactEventsFunction$',
          
                  # VoiceMail consumers
                  r'^[a-zA-Z0-9_-]+-VoiceMailAudioProcessingFunction$',
                  r'^[a-zA-Z0-9_-]+-VoiceMailTranscriberFunction$',
                  r'^[a-zA-Z0-9_-]+-VoiceMailPackagingFunction$'
              ]
          
              for pattern in consumer_patterns:
                  if re.match(pattern, function_name, re.IGNORECASE):
                      return True
          
              return False

          def is_scv_rule(rule_name: str) -> bool:
              """Check if rule is any SCV-related rule based on EventPattern content"""
              try:
                  # Get rule details to check EventPattern
                  rule_details = events_client.describe_rule(Name=rule_name)
                  event_pattern = rule_details.get('EventPattern')
          
                  if not event_pattern:
                      # Check rule name patterns for non-S3 rules
                      name_lower = rule_name.lower()
                      return (
                          'contacteventsrule' in name_lower or
                          'scheduledrule' in name_lower
                      )
          
                  # Parse EventPattern (could be string or dict)
                  if isinstance(event_pattern, str):
                      try:
                          pattern_obj = json.loads(event_pattern)
                      except json.JSONDecodeError:
                          return False
                  else:
                      pattern_obj = event_pattern
          
                  # Check for S3 voicemail rules - primary target
                  if 'aws.s3' in pattern_obj.get('source', []):
                      # Check if EventPattern contains voicemail paths
                      pattern_str = json.dumps(pattern_obj).lower()
                      voicemail_indicators = [
                          'voicemail_transcripts/',
                          'voicemail_recordings/'
                      ]
          
                      if any(indicator in pattern_str for indicator in voicemail_indicators):
                          logger.info(f"Found S3 voicemail rule: {rule_name}")
                          return True
          
                  # Check for Connect contact event rules
                  if 'aws.connect' in pattern_obj.get('source', []):
                      detail_types = pattern_obj.get('detail-type', [])
                      if 'Amazon Connect Contact Event' in detail_types:
                          logger.info(f"Found Connect contact events rule: {rule_name}")
                          return True
          
                  return False
          
              except events_client.exceptions.ResourceNotFoundException:
                  logger.debug(f"Rule {rule_name} not found")
                  return False
              except Exception as e:
                  logger.debug(f"Error checking rule {rule_name}: {str(e)}")
                  return False

          def send_cfn_response(event, context, response_status, response_data):
              """Send response to CloudFormation"""
              import urllib3
              import json
          
              response_url = event['ResponseURL']
              response_body = {
                  'Status': response_status,
                  'Reason': f'See CloudWatch Log Stream: {context.log_stream_name}',
                  'PhysicalResourceId': context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }
          
              json_response_body = json.dumps(response_body)
              headers = {'content-type': '', 'content-length': str(len(json_response_body))}
          
              http = urllib3.PoolManager()
              try:
                  response = http.request('PUT', response_url, headers=headers, body=json_response_body)
                  logger.info(f"CloudFormation response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Error sending CloudFormation response: {str(e)}")

  ExecuteMultiorgMigration:
    Type: Custom::MultiorgMigration
    Properties:
      ServiceToken: !GetAtt MultiorgMigrationFunction.Arn
      existing_call_center_api_name: !Ref ExistingCallCenterApiName
      lambda_prefix: !Ref lambdaPrefix
      connect_instance_id: !Ref ConnectInstanceId

Outputs:
  MultiorgMigrationFunctionArn:
    Description: ARN of the Multiorg Migration Lambda function
    Value: !GetAtt MultiorgMigrationFunction.Arn

  MigrationExecutionResult:
    Description: Result of the multiorg migration execution
    Value: !GetAtt ExecuteMultiorgMigration.status