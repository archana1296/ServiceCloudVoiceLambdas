Description: CloudFormation template for Secret Manager Lambda function and related resources

Parameters:
  CallCenterApiName:
    Type: String
    Description: Name of the Call Center API

  SalesforceOrgId:
    Type: String
    Description: Salesforce Organization ID

  OrgDomainName:
    Type: String
    Description: Salesforce Org Domain Name

  Scrt2MyDomainUrl:
    Type: String
    Description: SCRT2 MyDomain URL

  SalesforceRestApiAuthPrivateKeyValue:
    Default: salesforce-rest-api-auth-private-key-value
    Type: String
    Description: The value of the SSM parameter used to store the Salesforce REST API
      auth private key.
  SalesforceRestApiAuthConsumerKeyValue:
    Default: salesforce-rest-api-auth-consumer-key-value
    Type: String
    Description: The value of the SSM parameter used to store the Salesforce REST API
      auth consumer key.
  SalesforceRestApiAuthAccessTokenKeyValue:
    Default: salesforce-rest-api-auth-access-token-key-value
    Type: String
    Description: The value of the SSM parameter used to store the Salesforce REST API Access token.
  SalesforceRestApiAuthAudienceKeyValue:
    Default: salesforce-rest-api-auth-audience-key-value
    Type: String
    Description: The value of the SSM parameter used to store the Salesforce REST API Audience.
  SalesforceScrtJwtAuthPrivateKeyValue:
    Default: scrt-jwt-auth-private-key-value
    Type: String
    Description: The value of the SSM parameter used to store the SCRT JWT Auth Private Key.
  SalesforceRestApiAuthSubjectKeyValue:
    Default: salesforce-rest-api-auth-subject-key-value
    Type: String
    Description: The value of the SSM parameter used to store the Salesforce REST API Subject.
  SalesforceRelease:
    Type: String
    Description: Salesforce Major Release Version
    Default: 258.0
  LambdaPrefix:
    Default: ''
    Type: String
    Description: Prefix for Lambda functions

  Version:
    Type: String
    Description: Stack Version and Lambda Version
    Default: V19.0

  SecretConfiguratorLambdaRole:
    Type: String
    Description: Name of the IAM role that the SCVSecretConfigurator Lambda function will assume
    Default: SCVSecretConfiguratorLambdaRole

  PermissionBoundaryARN:
    Default: ''
    Type: String
    Description: IAM Permission Boundary ARN as defined by the admin

Transform: "AWS::Serverless-2016-10-31"
AWSTemplateFormatVersion: '2010-09-09'

Conditions:
  LambdaPrefixIsNull:
    !Equals [ !Ref LambdaPrefix, '' ]

Resources:
  # Lambda function to manage secret
  SCVSecretConfigurator:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If [LambdaPrefixIsNull, !Sub "${CallCenterApiName}-SCVSecretConfigurator", !Sub "${LambdaPrefix}-SCVSecretConfigurator"]
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${SecretConfiguratorLambdaRole}"
      Timeout: 60
      MemorySize: 128
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import cfnresponse
          from botocore.exceptions import ClientError
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          secrets_manager = boto3.client('secretsmanager')
          ssm = boto3.client('ssm')
          
          # Define protected key suffixes globally
          PROTECTED_KEY_SUFFIXES = [
              'scrt-jwt-auth-private-key',
              'salesforce-rest-api-access-token',
              'salesforce-rest-api-audience',
              'salesforce-rest-api-subject',
              'salesforce-rest-api-auth-consumer-key',
              'salesforce-rest-api-auth-private-key'
          ]
          
          # Define dynamic key property mappings globally
          DYNAMIC_KEY_PROPERTIES = {
              'CONSUMER_KEY_PARAM_NAME': 'CONSUMER_KEY_PARAM_VALUE',
              'PRIVATE_KEY_PARAM_NAME': 'PRIVATE_KEY_PARAM_VALUE',
              'ACCESS_TOKEN_PARAM_NAME': 'ACCESS_TOKEN_PARAM_VALUE',
              'AUDIENCE_PARAM_NAME': 'AUDIENCE_PARAM_VALUE',
              'SUBJECT_PARAM_NAME': 'SUBJECT_PARAM_VALUE',
              'AUTH_PRIVATE_KEY_PARAM_NAME': 'AUTH_PRIVATE_KEY_PARAM_VALUE'
          }
          
          def create_default_secret_template(properties):
              """
              Create default secret template from CloudFormation properties
              Returns tuple: (default_secret_template, default_secret_string)
              """
              # Exclude dynamic key property names and values (the *_PARAM_NAME and *_PARAM_VALUE properties)
              excluded_properties = set(DYNAMIC_KEY_PROPERTIES.keys()) | set(DYNAMIC_KEY_PROPERTIES.values())
          
              # Build the secret template from properties
              default_secret_template = {}
          
              # Add dynamic keys with their parameter names as actual keys
              for param_name, param_value in DYNAMIC_KEY_PROPERTIES.items():
                  if param_name in properties and param_value in properties:
                      dynamic_key_name = properties[param_name]
                      dynamic_key_value = properties[param_value]
                      default_secret_template[dynamic_key_name] = dynamic_key_value
          
              # Add all other properties as template keys
              for prop_name, prop_value in properties.items():
                  if prop_name not in excluded_properties:
                      default_secret_template[prop_name] = prop_value
          
              default_secret_string = json.dumps(default_secret_template, sort_keys=True)
              logger.info(f"Generated default secret template with {len(default_secret_template)} keys")
          
              return default_secret_template, default_secret_string
          
          def get_ssm_parameters_batch(parameter_names):              
              ssm_values = {}
              if not parameter_names:
                  return ssm_values                            
              for parameter_name in parameter_names:
                  try:
                      response = ssm.get_parameter(Name=parameter_name, WithDecryption=True)
                      ssm_values[parameter_name] = response['Parameter']['Value']
                      logger.info(f"SSM parameter found: {parameter_name}")
                  except ssm.exceptions.ParameterNotFound:
                      logger.info(f"SSM parameter not found: {parameter_name}")
                  except Exception as e:
                      logger.warning(f"Error reading SSM parameter {parameter_name}: {e}")
              logger.info(f"Reading: {len(parameter_names)} parameters from SSM: {parameter_names}: Retrieved: {len(ssm_values)}")              
              return ssm_values
          
          def apply_ssm_values_to_secret(secret_dict, ssm_values):              
              updated_secret_dict = secret_dict.copy()
              applied_count = 0              
              for key, ssm_value in ssm_values.items():
                  if key in updated_secret_dict:
                      updated_secret_dict[key] = ssm_value
                      applied_count += 1
                      logger.info(f"Applied SSM value for key: {key}")              
              if applied_count > 0:
                  logger.info(f"Applied {applied_count} SSM values to secret")
          
              return updated_secret_dict
          
          def collect_ssm_keys_from_secret(secret_dict, call_center_api_name=None):              
              # Build full protected key names with CallCenterApiName prefix
              protected_key_names = []
              if call_center_api_name:
                  protected_key_names = [f"{call_center_api_name}-{suffix}" for suffix in PROTECTED_KEY_SUFFIXES]
                  logger.info(f"Protected key names with prefix: {protected_key_names}")
          
              def is_protected_key(key):                  
                  return key in protected_key_names
          
              ssm_keys = [key for key in secret_dict.keys() if is_protected_key(key)]
              logger.info(f"Found {len(ssm_keys)} protected keys for SSM lookup: {ssm_keys}")
              return ssm_keys
          
          def merge_existing_secret_with_template(existing_secret_response, default_secret_template, request_type='Update', call_center_api_name=None):              
              try:
                  # Build full protected key names with CallCenterApiName prefix
                  protected_key_names = []
                  if call_center_api_name:
                      protected_key_names = [f"{call_center_api_name}-{suffix}" for suffix in PROTECTED_KEY_SUFFIXES]
                      logger.info(f"Protected key names with prefix: {protected_key_names}")
          
                  def is_protected_key(key):                      
                      return key in protected_key_names
          
                  # Parse existing secret
                  existing_secret_string = existing_secret_response['SecretString']
                  existing_secret_dict = json.loads(existing_secret_string)
                  logger.info(f"Existing secret has {len(existing_secret_dict)} keys: {list(existing_secret_dict.keys())}")
          
                  # Start with default template (this ensures template values take precedence)
                  merged_secret_dict = default_secret_template.copy()
                  logger.info(f"Starting with default template - {len(default_secret_template)} keys")
          
                  # Collect SSM keys needed for Create requests
                  ssm_keys_needed = []
          
                  # Identify different key categories
                  existing_keys = set(existing_secret_dict.keys())
                  template_keys = set(default_secret_template.keys())
          
                  # Keys that exist in both - handle with protection logic
                  overlapping_keys = existing_keys.intersection(template_keys)
                  if overlapping_keys:
                      logger.info(f"Processing {len(overlapping_keys)} overlapping keys:")
          
                      # Separate protected and non-protected overlapping keys
                      protected_overlapping = [key for key in overlapping_keys if is_protected_key(key)]
                      regular_overlapping = [key for key in overlapping_keys if not is_protected_key(key)]
          
                      # Handle protected keys 
                      if protected_overlapping:
                          if request_type == 'Create':
                              logger.info(f"Protected keys (Create - will check SSM, fallback to existing): {protected_overlapping}")
                              for key in protected_overlapping:
                                  # For Create: set existing value as fallback (SSM will be checked later)
                                  merged_secret_dict[key] = existing_secret_dict[key]  # fallback value
                                  logger.info(f"  {key}: fallback to existing value, will check SSM later")
                          else:
                              logger.info(f"Protected keys (Update - preserving existing values): {protected_overlapping}")
                              for key in protected_overlapping:
                                  # For Update: always use existing values
                                  merged_secret_dict[key] = existing_secret_dict[key]                              
          
                      # Handle regular overlapping keys - preserve existing values during Update
                      if regular_overlapping:
                          if request_type == 'Create':
                              logger.info(f"Regular overlapping keys (Create - using template values): {regular_overlapping}")                              
                          else:
                              logger.info(f"Regular overlapping keys (Update - preserving existing values): {regular_overlapping}")
                              for key in regular_overlapping:                                  
                                  merged_secret_dict[key] = existing_secret_dict[key]
                                  logger.info(f"  {key}: preserved existing value")                              
          
                  # Keys that exist only in existing secret (will be preserved)
                  existing_only_keys = existing_keys - template_keys
                  if existing_only_keys:
                      logger.info(f"Keys to preserve from existing secret: {list(existing_only_keys)}")
                      for key in existing_only_keys:
                          merged_secret_dict[key] = existing_secret_dict[key]
          
                  # Keys that exist only in template (already included in merged_secret_dict)
                  template_only_keys = template_keys - existing_keys
                  if template_only_keys:
                      logger.info(f"New keys added to secret: {len(template_only_keys)}")
          
                  # For Create requests, collect ALL protected keys in the final merged secret for SSM lookup
                  if request_type == 'Create':
                      all_protected_keys_in_merged = [key for key in merged_secret_dict.keys() if is_protected_key(key)]
                      ssm_keys_needed = all_protected_keys_in_merged
                      logger.info(f"All protected keys in merged secret for SSM lookup: {ssm_keys_needed}")
          
                  merged_secret_string = json.dumps(merged_secret_dict, sort_keys=True)
                  logger.info(f"Final merged secret has {len(merged_secret_dict)} keys")
          
                  return merged_secret_dict, merged_secret_string, ssm_keys_needed
          
              except (json.JSONDecodeError, KeyError) as e:
                  logger.warning(f"Could not parse existing secret, using default template only: {e}")
                  default_secret_string = json.dumps(default_secret_template, sort_keys=True)
                  return default_secret_template, default_secret_string, []
          
          def lambda_handler(event, context):
              try:
                  logger.info("Starting secret manager function")
                  logger.info(f"Event: {json.dumps(event, default=str)}")
          
                  request_type = event.get('RequestType')
                  logger.info(f"RequestType: {request_type}")
          
                  # Get secret name from resource properties
                  secret_name = event['ResourceProperties']['SecretName']
                  logger.info(f"Looking for secret: {secret_name}")
          
                  # Read all properties from the custom resource and generate template
                  properties = event['ResourceProperties']
                  logger.info(f"Available properties: {list(properties.keys())}")
          
                  # Extract secret template properties from nested structure
                  secret_template_properties = properties.get('SecretTemplate', {})
                  logger.info(f"Secret template properties: {list(secret_template_properties.keys())}")
          
                  # Get CallCenterApiName from the secret template
                  call_center_api_name = secret_template_properties.get('CALL_CENTER_API_NAME')
                  logger.info(f"CallCenterApiName: {call_center_api_name}")
          
                  # Create default secret template
                  default_secret_template, default_secret_string = create_default_secret_template(secret_template_properties)
          
                  response_data = {}
          
                  if request_type == 'Create':
                      logger.info("Handling CREATE request")
                      try:
                          # Check if secret already exists
                          try:
                              existing_secret = secrets_manager.get_secret_value(
                                  SecretId=secret_name,
                                  VersionStage='AWSCURRENT'
                              )
                              logger.info(f"Secret {secret_name} already exists, merging with template")
          
                              # Merge existing secret with template
                              merged_secret_dict, merged_secret_string, ssm_keys_from_merge = merge_existing_secret_with_template(existing_secret, default_secret_template, request_type, call_center_api_name)
          
                              # Read SSM values for all needed keys at once
                              if ssm_keys_from_merge:
                                  logger.info("Reading SSM Parameter Store values for protected keys")
                                  ssm_values = get_ssm_parameters_batch(ssm_keys_from_merge)
                                  merged_secret_dict = apply_ssm_values_to_secret(merged_secret_dict, ssm_values)
                                  merged_secret_string = json.dumps(merged_secret_dict, sort_keys=True)
          
                              # Update the secret with merged content
                              update_response = secrets_manager.update_secret(
                                  SecretId=secret_name,
                                  Description="Secret containing configuration for MultiOrg integration",
                                  SecretString=merged_secret_string
                              )
                              logger.info(f"Updated secret {secret_name} with merged content")
          
                              response_data = {
                                  'SecretExists': True,
                                  'SecretName': secret_name,
                                  'KeyCount': len(merged_secret_dict),
                                  'SecretArn': update_response.get('ARN', ''),
                                  'VersionId': update_response.get('VersionId', ''),
                                  'Updated': True,
                                  'Created': False,
                                  'message': f'Secret {secret_name} updated with merged content - {len(merged_secret_dict)} keys'
                              }
          
                          except secrets_manager.exceptions.ResourceNotFoundException:
                              # Secret doesn't exist, create it
                              logger.info(f"Creating new secret: {secret_name}")
          
                              # Collect all SSM keys needed and read them at once
                              final_secret_dict = default_secret_template.copy()
                              ssm_keys_needed = collect_ssm_keys_from_secret(final_secret_dict, call_center_api_name)
          
                              if ssm_keys_needed:
                                  logger.info("Reading SSM Parameter Store values for protected keys")
                                  ssm_values = get_ssm_parameters_batch(ssm_keys_needed)
                                  final_secret_dict = apply_ssm_values_to_secret(final_secret_dict, ssm_values)
          
                              final_secret_string = json.dumps(final_secret_dict, sort_keys=True)
          
                              create_response = secrets_manager.create_secret(
                                  Name=secret_name,
                                  Description="Secret containing configuration for MultiOrg integration",
                                  SecretString=final_secret_string
                              )
                              logger.info(f"Successfully created secret: {secret_name}")
          
                              response_data = {
                                  'SecretExists': True,
                                  'SecretName': secret_name,
                                  'KeyCount': len(final_secret_dict),
                                  'SecretArn': create_response.get('ARN', ''),
                                  'VersionId': create_response.get('VersionId', ''),
                                  'Updated': False,
                                  'Created': True,
                                  'message': f'Successfully created secret {secret_name} with {len(final_secret_dict)} keys'
                              }
          
                      except ClientError as e:
                          error_code = e.response['Error']['Code']
                          logger.error(f"AWS error creating secret {secret_name}: {error_code} - {e}")
                          response_data = {
                              'SecretExists': False,
                              'SecretName': secret_name,
                              'KeyCount': 0,
                              'SecretArn': '',
                              'VersionId': '',
                              'Updated': False,
                              'Created': False,
                              'message': f'Error creating secret {secret_name}: {error_code}',
                              'error': str(e)
                          }
          
                  elif request_type == 'Update':
                      logger.info("Handling UPDATE request")
                      try:
                          # Check if secret exists
                          try:
                              existing_secret = secrets_manager.get_secret_value(
                                  SecretId=secret_name,
                                  VersionStage='AWSCURRENT'
                              )
                              logger.info(f"Updating existing secret: {secret_name}")
          
                              # Merge existing secret with template (no SSM reading for Update)
                              merged_secret_dict, merged_secret_string, _ = merge_existing_secret_with_template(existing_secret, default_secret_template, request_type, call_center_api_name)
          
                              # Update the secret with merged content
                              update_response = secrets_manager.update_secret(
                                  SecretId=secret_name,
                                  Description="Secret containing configuration for MultiOrg integration",
                                  SecretString=merged_secret_string
                              )
                              logger.info(f"Successfully updated secret: {secret_name}")
          
                              response_data = {
                                  'SecretExists': True,
                                  'SecretName': secret_name,
                                  'KeyCount': len(merged_secret_dict),
                                  'SecretArn': update_response.get('ARN', ''),
                                  'VersionId': update_response.get('VersionId', ''),
                                  'Updated': True,
                                  'Created': False,
                                  'message': f'Successfully updated secret {secret_name} with {len(merged_secret_dict)} keys'
                              }
          
                          except secrets_manager.exceptions.ResourceNotFoundException:
                              logger.error(f"Secret {secret_name} doesn't exist - cannot update non-existent secret")
                              response_data = {
                                  'SecretExists': False,
                                  'SecretName': secret_name,
                                  'KeyCount': 0,
                                  'SecretArn': '',
                                  'VersionId': '',
                                  'Updated': False,
                                  'Created': False,
                                  'message': f'Error: Cannot update secret {secret_name} - secret does not exist',
                                  'error': 'Secret not found for update operation'
                              }
          
                      except ClientError as e:
                          error_code = e.response['Error']['Code']
                          logger.error(f"AWS error updating secret {secret_name}: {error_code} - {e}")
                          response_data = {
                              'SecretExists': False,
                              'SecretName': secret_name,
                              'KeyCount': 0,
                              'SecretArn': '',
                              'VersionId': '',
                              'Updated': False,
                              'Created': False,
                              'message': f'Error updating secret {secret_name}: {error_code}',
                              'error': str(e)
                          }
          
                  elif request_type == 'Delete':
                      logger.info("Handling DELETE request - doing nothing (preserving secret)")
                      response_data = {
                          'SecretExists': True,
                          'SecretName': secret_name,
                          'KeyCount': 0,
                          'SecretArn': '',
                          'VersionId': '',
                          'Updated': False,
                          'Created': False,
                          'message': f'DELETE request received for {secret_name} - no action taken (secret preserved)'
                      }
          
                  else:
                      logger.warning(f"Unsupported request type: {request_type}")
                      response_data = {
                          'SecretExists': False,
                          'SecretName': secret_name,
                          'KeyCount': 0,
                          'SecretArn': '',
                          'VersionId': '',
                          'Updated': False,
                          'Created': False,
                          'message': f'Unsupported request type: {request_type}'
                      }
          
                  # Determine CloudFormation response status
                  if request_type == 'Update' and not response_data.get('SecretExists', True):
                      # Fail the update if secret doesn't exist
                      logger.error("Failing CloudFormation update - secret does not exist")
                      cfn_status = cfnresponse.FAILED
                  else:
                      cfn_status = cfnresponse.SUCCESS
          
                  logger.info(f"Response data: {response_data}")
                  cfnresponse.send(event, context, cfn_status, response_data)
          
                  return {
                      'statusCode': 200,
                      'body': response_data
                  }
          
              except Exception as e:
                  logger.error(f"Lambda execution failed: {e}")
          
                  error_response = {
                      'SecretExists': False,
                      'SecretName': event['ResourceProperties']['SecretName'],
                      'KeyCount': 0,
                      'SecretArn': '',
                      'VersionId': '',
                      'Updated': False,
                      'Created': False,
                      'message': 'Failed to process secret',
                      'error': str(e)
                  }
          
                  cfnresponse.send(event, context, cfnresponse.FAILED, error_response)
          
                  return {
                      'statusCode': 500,
                      'body': error_response
                  }

  # Custom resource to trigger the secret manager function
  SecretManagerCustomResource:
    Type: Custom::SecretManager
    DependsOn: SCVSecretConfigurator
    Properties:
      ServiceToken: !GetAtt SCVSecretConfigurator.Arn
      SecretName: !Sub '${CallCenterApiName}-salesforce-secret'
      # Include SalesforceRelease and Version to trigger updates when they change
      SalesforceRelease: !Ref SalesforceRelease
      Version: !Ref Version
      # Secret template properties
      SecretTemplate:
        CALL_CENTER_API_NAME: !Ref CallCenterApiName
        AUDIENCE_PARAM_NAME: !Sub '${CallCenterApiName}-salesforce-rest-api-audience'
        AUDIENCE_PARAM_VALUE: !Sub '${SalesforceRestApiAuthAudienceKeyValue}'
        CONSUMER_KEY_PARAM_NAME: !Sub '${CallCenterApiName}-salesforce-rest-api-auth-consumer-key'
        CONSUMER_KEY_PARAM_VALUE: !Sub '${SalesforceRestApiAuthConsumerKeyValue}'
        AUTH_PRIVATE_KEY_PARAM_NAME: !Sub '${CallCenterApiName}-salesforce-rest-api-auth-private-key'
        AUTH_PRIVATE_KEY_PARAM_VALUE: !Sub '${SalesforceRestApiAuthPrivateKeyValue}'
        PRIVATE_KEY_PARAM_NAME: !Sub '${CallCenterApiName}-scrt-jwt-auth-private-key'
        PRIVATE_KEY_PARAM_VALUE: !Sub '${SalesforceScrtJwtAuthPrivateKeyValue}'
        SUBJECT_PARAM_NAME: !Sub '${CallCenterApiName}-salesforce-rest-api-subject'
        SUBJECT_PARAM_VALUE: !Sub '${SalesforceRestApiAuthSubjectKeyValue}'
        SALESFORCE_AUTH_ENDPOINT: !Sub '${OrgDomainName}/services/oauth2/token'
        SALESFORCE_ORG_ID: !Ref SalesforceOrgId
        SALESFORCE_REST_API_ENDPOINT_BASE: !Sub '${OrgDomainName}/services/data/v64.0'
        SCRT_ENDPOINT_BASE: !Ref Scrt2MyDomainUrl
        TRANSCRIBE_REGION: 'us-west-2'

  SecretManagerCustomAccessResource:
    Type: Custom::SecretManager
    DependsOn: SCVSecretConfigurator
    Properties:
      ServiceToken: !GetAtt SCVSecretConfigurator.Arn
      SecretName: !Sub '${CallCenterApiName}-salesforce-access-secret'
      SalesforceRelease: !Ref SalesforceRelease
      Version: !Ref Version
      SecretTemplate:
        ACCESS_TOKEN_PARAM_NAME: !Sub '${CallCenterApiName}-salesforce-rest-api-access-token'
        ACCESS_TOKEN_PARAM_VALUE: !Sub '${SalesforceRestApiAuthAccessTokenKeyValue}'

Outputs:

  # Secret Manager Outputs
  SecretArn:
    Description: ARN of the created/updated secret
    Value: !GetAtt SecretManagerCustomResource.SecretArn

  SecretManagerFunctionArn:
    Description: ARN of the SecretManager Lambda function
    Value: !GetAtt SCVSecretConfigurator.Arn