const SCVLoggingUtil = require("./SCVLoggingUtil");
const utils = require("./utils");
const axiosWrapper = require("./axiosWrapper");

const vendorFQN = "amazon-connect";

/**
 * Create conversation states and records at Salesforce side to represent an Amazon Connect contact.
 *
 * @param {object} fieldValues - Metadata and data of the to-be-created VoiceCall conversation.
 * @param {string} fieldValues.callCenterApiName - API name of the CallCenter setup record to which this VoiceCall belongs.
 * @param {string} fieldValues.parentVoiceCallId - The ID of the parent VoiceCall from which the current VoiceCall was transferred.
 * @param {string} fieldValues.vendorCallKey - The vendor-specific ID of this VoiceCall.
 * @param {string} fieldValues.to - The `to` phone number of this VoiceCall.
 * @param {string} fieldValues.from - The `from` phone number of this VoiceCall.
 * @param {string} fieldValues.initiationMethod - Specifies how this VoiceCall was created. E.g., "Inbound", "Outbound", "Transfer".
 * @param {string} fieldValues.startTime - The start timestamp of this VoiceCall.
 * @param {string} fieldValues.callAttributes - JSON containing key-value pairs of attributes set in contact flow.
 * @param {array}  fieldValues.participants - The participants of this VoiceCall.
 * @param {string} fieldValues.participants[0].participantKey - The vendor-specifc unique identifier of a participant.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object} result.voiceCallRecordId - The SObject ID of the created VoiceCall record.
 * @return {object} result.errors - Field errors and record creation errors.
 */
async function createVoiceCall(fieldVals, configData) {
  SCVLoggingUtil.info({
    message: "CreateVoiceCall Request created",
    context: { contactId: fieldVals.vendorCallKey },
  });
  const fieldValues = fieldVals;
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);

  fieldValues.callCenterApiName = generateJWTParams.callCenterApiName;

  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .post("/voiceCalls", fieldValues, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
        "Telephony-Provider-Name": vendorFQN,
      },
    })
    .then((response) => response)
    .catch((error) => {
      SCVLoggingUtil.error({
        message: "Error creating VoiceCall record",
        context: { payload: error },
      });
      throw new Error("Error creating VoiceCall record");
    });

  return responseVal.data;
}

/**
 * Update a VoiceCall record at Salesforce side.
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the to-be-updated VoiceCall record.
 * @param {object} fieldValues - Metadata and data of the to-be-updated VoiceCall record.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function updateVoiceCall(contactId, fieldValues, configData) {
  SCVLoggingUtil.info({
    message: "updateVoiceCall Request created",
    context: { contactId: contactId },
  });
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };
  const jwt = await utils.generateJWT(generateJWTParams);

  const patchResponse = await axiosWrapper.getScrtEndpoint(configData)
    .patch(`/voiceCalls/${contactId}`, fieldValues, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
        "Telephony-Provider-Name": vendorFQN,
      },
    })
    .then((response) => response)
    .catch((error) => {
      SCVLoggingUtil.error({
        message: "Error updating VoiceCall record",
        context: { payload: error },
      });
      throw new Error(`Error updating VoiceCall record.`);
    });

  return patchResponse.data;
}

/**
 * Execute an Omni Flow for  a VoiceCall record at Salesforce side.
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the VoiceCall record for which routing instructions need to be generated by excuting the flow.
 * @param {object} payload - Contains flowDevName, fallbackQueue, transferTarget if present and any additional flowInputParameters.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function executeOmniFlow(contactId, payload, configData) {
  SCVLoggingUtil.info({
    message: "executeOmniFlow Request created",
    context: { contactId: contactId },
  });
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);
  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .patch(`/voiceCalls/${contactId}/omniFlow`, payload, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
        "Telephony-Provider-Name": vendorFQN,
      },
    })
    .then((response) => response)
    .catch((error) => {
      SCVLoggingUtil.error({
        message: `Error executing Omni Flow with ${contactId}`,
        context: { payload: error },
      });
      throw new Error("Error executing Omni Flow");
    });

  return responseVal.data;
}

/**
 * Send a messgage to Telephony Integration API.
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the VoiceCall record for which messages need to be sent.
 * @param {object} payload - Contains message.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function sendMessage(contactId, payload, configData) {
  SCVLoggingUtil.info({
    message: "sendMessage Request created",
    context: { contactId: contactId },
  });

  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);
  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .post(`/voiceCalls/${contactId}/messages`, payload, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
        "Telephony-Provider-Name": vendorFQN,
      },
    })
    .then((response) => {
      SCVLoggingUtil.info({
        message: `Successfully sent transcript with ${contactId}`,
        context: { payload: response },
      });
      return response;
    })
    .catch((error) => {
      SCVLoggingUtil.error({
        message: `Error sending transcript with ${contactId}`,
        context: { payload: error },
      });
      // Do not throw error; failing lambda execution will keep Kinesis records in stream
      return { data: { result: "Error" } };
    });

  return responseVal.data;
}

/**
 * Cancel Omni Flow Execution for Voicecall
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the VoiceCall record for which PSR needs to be cleared.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function cancelOmniFlowExecution(contactId, configData) {
  SCVLoggingUtil.info({
    message: "cancelOmniFlowExecution Request created",
    context: { contactId: contactId },
  });
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);

  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .patch(`/voiceCalls/${contactId}/clearRouting`, null, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
      },
    })
    .then((response) => response)
    .catch((error) => {
      SCVLoggingUtil.error({
        message: `Error cancelling OmniFlowExecution with ${contactId}`,
        context: { payload: error },
      });
      throw new Error("Error cancelling OmniFlowExecution");
    });

  return responseVal.data;
}

/**
 * Reroute Flow Execution for Voice call
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the VoiceCall record which has to be rerouted.
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function rerouteFlowExecution(contactId, configData) {
  SCVLoggingUtil.info({
    message: "rerouteFlowExecution Request created",
    context: { contactId: contactId },
  });
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);
  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
      .patch(`/voiceCalls/${contactId}/reroute`, null, {
        headers: {
          Authorization: `Bearer ${jwt}`,
          "Content-Type": "application/json",
        },
      })
      .then((response) => {
        SCVLoggingUtil.info({
          message: `Successfully triggered call rerouting for ${contactId}`,
          context: { payload: response },
        });
        return response;
      })
      .catch((error) => {
        SCVLoggingUtil.error({
          message: `Error in Reroute Flow Execution with ${contactId}`,
          context: { payload: error },
        });
        throw new Error("Error in Reroute Flow Execution");
      });
  return responseVal.data;
}

/**
 * Callback Flow Execution for Voice call
 *
 * @param contactId - The vendor-specific ID or the SObject ID of the VoiceCall record which has to be rerouted.
 * @param payload - Contains customer phone number
 * @param configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function callbackExecution(contactId, payload, configData) {
  SCVLoggingUtil.info({
    message: "Callback Request created",
    context: { contactId: contactId },
  });

  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };

  const jwt = await utils.generateJWT(generateJWTParams);
  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .post(`/voiceCalls/${contactId}/requestCallback`, payload, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json"
      },
    })
    .then((response) => {
      SCVLoggingUtil.info({
        message: `Successfully triggered callback request for ${contactId}`,
        context: { payload: response },
      });
      return response;
    })
    .catch((error) => {
      SCVLoggingUtil.error({
        message: `Error in Callback request execution with ${contactId}`,
        context: { payload: error },
      });
      throw new Error("Error in Callback Execution");
    });
  return responseVal.data;
}

/**
 * Route Voice Call to an Agent, Queue, or Flow
 *
 * @param {string} contactId - The vendor-specific ID or the SObject ID of the VoiceCall record which needs to be routed.
 * @param {object} payload - Contains routingTarget (required), fallbackQueue (optional), and flowInputParameters (optional).
 * @param {object} configData - Configuration data containing orgId, callCenterApiName, privateKey, etc.
 *
 * @return {object}
 */
async function routeVoiceCall(contactId, payload, configData) {
  SCVLoggingUtil.info({
    message: "Route Voice Call Request created",
    context: { contactId: contactId },
  });
  
  const generateJWTParams = {
    orgId: configData.orgId,
    callCenterApiName: configData.callCenterApiName,
    expiresIn: configData.tokenValidFor,
    privateKey: configData.privateKey,
  };
  
  const jwt = await utils.generateJWT(generateJWTParams);
  const responseVal = await axiosWrapper.getScrtEndpoint(configData)
    .patch(`/voiceCalls/route/${contactId}`, payload, {
      headers: {
        Authorization: `Bearer ${jwt}`,
        "Content-Type": "application/json",
        "Telephony-Provider-Name": vendorFQN,
      },
    })
    .then((response) => {
      SCVLoggingUtil.info({
        message: `Successfully routed voice call for ${contactId}`,
        context: { payload: response },
      });
      return response;
    })
    .catch((error) => {
      SCVLoggingUtil.error({
        message: `Error routing voice call with ${contactId}`,
        context: { payload: error },
      });
      throw new Error("Error routing voice call");
    });
  return responseVal.data;
}

module.exports = {
  createVoiceCall,
  updateVoiceCall,
  executeOmniFlow,
  sendMessage,
  cancelOmniFlowExecution,
  rerouteFlowExecution,
  callbackExecution,
  routeVoiceCall
};
